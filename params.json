{"name":"Iron response","tagline":"Provide a response object to remote worker scripts.","body":"[![Code Climate](https://codeclimate.com/github/adelevie/iron_response.png)](https://codeclimate.com/github/adelevie/iron_response) [![Gem Version](https://badge.fury.io/rb/iron_response.png)](http://badge.fury.io/rb/iron_response)\r\n\r\n# iron_response\r\n\r\nGlues together IronWorker and AWS S3 to provide a response object to remote worker scripts. This allows you to write massively concurrent Ruby programs without worrying about threads.\r\n\r\n```ruby\r\nrequire \"iron_response\"\r\n\r\nconfig = {...}\r\nbatch = IronResponse::Batch.new\r\n\r\nbatch.auto_update_worker = true\r\nbatch.config[:iron_io]   = config[:iron_io]\r\nbatch.config[:aws_s3]    = config[:aws_s3]\r\nbatch.worker             = \"test/workers/is_prime.rb\"\r\nbatch.params_array       = Array(1..10).map {|i| {number: i}}\r\n\r\nresults                  = batch.run!\r\n\r\np results\r\n#=> [{\"result\"=>false}, {\"result\"=>true}, {\"result\"=>true}...]\r\n```\r\n\r\nAssumes you have a worker file called `is_prime.rb`:\r\n```ruby\r\nrequire \"iron_response\"\r\n\r\nIronResponse::Responder.new(binding) do\r\n  def is_prime?(n)\r\n    (\"1\" * n =~ /^1?$|^(11+?)\\1+$/) == 0 ? false : true\r\n  end\r\n\r\n  {\r\n   result: is_prime?(params[:number])\r\n  }\r\nend\r\n```\r\n\r\n## Rationale\r\n\r\nIron.io's IronWorker is a great product that provides a lot of powerful concurrency options. With IronWorker, you can scale tasks to hundreds and even thousands of workers. However, IronWorker was missing one useful feature for me: responses. What do I mean? In the typical IronWorker setup, worker files are just one-off scripts that run independently of the client that queues them up. For example:\r\n\r\n```ruby\r\nclient = IronWorkerNG::Client.new\r\n100.times do |i|\r\n  client.tasks.create(\"do_something\", number: i)\r\nend\r\n```\r\n\r\nFor many use cases, this is fine. But what if I want to know the result of `do_something`? A simple way to get the result would be for your worker to POST the final result somewhere, then have the client retrieve it. This gem simply abstracts that process away, allowing the developer to avoid boilerplate and to keep worker code elegant.\r\n\r\nOn top of all this, another benefit to using this gem is that it makes it much easier to test workers.\r\n\r\nUnder the hood, `iron_response` uses some functional and meta-programming to capture the final expression of a worker file, convert it to JSON, and then POST it to Amazon S3. When all the workers in an `IronResponse::Batch` have finished, the gem retrieves the file and converts the JSON string back to Ruby.\r\n\r\nThis process means there a few important implications:\r\n\r\n- Response objects \"sent\" from workers should be JSON-parseable. This means sticking to basic Ruby objects and data structures such as `String`, `Fixnum`, `Hash`, and `Array`.\r\n- Though these objects must be parseable, they can be fairly large. Though I haven't figured out exactly what the limit is, you really are only constrained by IronWorker's RAM and HD limits, and the bandwidth between the client (your computer/server), IronWorker servers, and S3. In an ideal setup, all three of these components are inside of Amazon's cloud, allowing you to get very fast throughput.\r\n\r\n## Usage\r\n\r\nThis gem requires a basic understanding of how to use [IronWorker with Ruby](https://github.com/iron-io/iron_worker_ruby_ng).\r\n\r\nAssuming you have an empy directory, called `foo`:\r\n\r\n```sh\r\n$ mkdir workers\r\n$ cd workers\r\n$ touch my_worker.rb\r\n```\r\n\r\n`my_worker.rb` should look like this:\r\n\r\n```ruby\r\nrequire \"iron_response\"\r\n\r\nIronResponse::Responder.new(binding) do\r\n  # your code here\r\nend\r\n```\r\n\r\nTo run this worker, create at the top-level of `foo` files called `configuration.rb` and `enqueue.rb`:\r\n\r\n`configuration.rb`:\r\n```ruby\r\nclass Configuration\r\n  def self.keys\r\n    {\r\n      iron_io: {\r\n        token:      \"123\",\r\n        project_id: \"123\"\r\n      },\r\n      aws_s3: {\r\n        access_key_id:     \"123\",\r\n        secret_access_key: \"123\",\r\n        bucket:            \"iron_response\"\r\n      }\r\n    }\r\n  end\r\nend\r\n```\r\n\r\nObviously, fill in the appropriate API keys. It is highly recommended that you do not use your AWS master keys. Instead, go to the AWS Console, click on \"IAM\", and create a user with a policy that allows it to edit the bucket named in the configuration file. Here's an example policy:\r\n\r\n```json\r\n{\r\n  \"Statement\": [\r\n    {\r\n      \"Action\": \"s3:*\",\r\n      \"Effect\": \"Allow\",\r\n      \"Resource\": [\r\n        \"arn:aws:s3:::iron_response\",\r\n        \"arn:aws:s3:::iron_response/*\"\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nNow, write your queueing script:\r\n\r\n`enqueue.rb`:\r\n```ruby\r\nrequire_relative \"configuration\"\r\nrequire \"iron_response\"\r\n\r\nconfig = Configuration.keys\r\nbatch = IronResponse::Batch.new\r\n\r\nbatch.auto_update_worker = true\r\nbatch.config             = config\r\nbatch.worker             = \"workers/my_worker.rb\"\r\n\r\n# The `params_array` is an Array of Hashes \r\n# that get sent as the payload to IronWorker scripts.\r\nbatch.params_array       = Array (\"a\"..\"z\").map {|i| {letter: i}}\r\n\r\nresults                  = batch.run!\r\n```\r\n\r\nIf your worker code requires any gems, you can use [`iron_worker_ng`](https://github.com/iron-io/iron_worker_ruby_ng)'s API:\r\n\r\n```ruby\r\nbatch.code.merge_gem(\"nokogiri\", \"< 1.6.0\") # decreases remote build time\r\nbatch.code.merge_gem(\"ecfs\")\r\nbatch.code.full_remote_build(true)\r\n```\r\n\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem \"iron_response\"\r\n```\r\n\r\nAnd then execute:\r\n\r\n```sh\r\n$ bundle\r\n```\r\n\r\nOr install it yourself as:\r\n\r\n```sh\r\n$ gem install iron_response\r\n```\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Added some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}